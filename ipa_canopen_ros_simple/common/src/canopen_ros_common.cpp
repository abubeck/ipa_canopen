//ROS typedefs
#include "ros/ros.h"
#include <control_msgs/JointTrajectoryControllerState.h>
#include <sensor_msgs/JointState.h>
#include <diagnostic_msgs/DiagnosticArray.h>
#include <std_msgs/String.h>
#include <brics_actuator/JointVelocities.h>
#include <cob_srvs/Trigger.h>
#include <cob_srvs/Trigger.h>

/* protected region user include files on begin */
#include <canopen.h>
#include <urdf/model.h>
/* protected region user include files end */

class canopen_ros_config
{
public:
		std::string can_device;
		int can_baudrate;
		std::string modul_ids;
		std::string joint_names;
		std::string robot_description;

};

class canopen_ros_data
{
// autogenerated: don't touch this class
public:
//input data
    	brics_actuator::JointVelocities in_command_vel;
  
	
//output data
    	control_msgs::JointTrajectoryControllerState out_state;
    	sensor_msgs::JointState out_joint_states;
    	diagnostic_msgs::DiagnosticArray out_diagnostics;
    	std_msgs::String out_current_operationmode;
 

};

class canopen_ros_impl
{
	/* protected region user member variables on begin */
	bool is_initialized_;
	int dof_;
	std::vector<std::string> joint_names_; // HACK: does not work yet because BRIDE doesn't support list parameters
	/* protected region user member variables end */

public:
    canopen_ros_impl() 
    {
        /* protected region user constructor on begin */
    	is_initialized_ = false;
    	dof_ = 0;
    	joint_names_.push_back("arm_1_joint"); // HACK: does not work yet because BRIDE doesn't support list parameters
    	joint_names_.push_back("arm_2_joint"); // HACK: does not work yet because BRIDE doesn't support list parameters
    	joint_names_.push_back("arm_3_joint"); // HACK: does not work yet because BRIDE doesn't support list parameters
		/* protected region user constructor end */
    }
    void configure(canopen_ros_config config) 
    {
        /* protected region user configure on begin */
    	// get dof from joint_names vector
    	std::cout << "joint_names: " << config.joint_names << std::endl;
    	// dof_ = config.joint_names.size();
    	dof_ = joint_names_.size(); // HACK: does not work yet because BRIDE doesn't support list parameters
    	ROS_INFO("DOF: %d", dof_);

    	if (config.robot_description.size() == 0)
    	{
    		ROS_ERROR("Unable to load robot model from parameter robot_description, shutting down node...");
    		exit(EXIT_FAILURE);
    	}

    	/// Get urdf model out of robot_description
		urdf::Model model;
		if (!model.initString(config.robot_description))
		{
			ROS_ERROR("Failed to parse urdf file, shutting down node...");
			exit(EXIT_FAILURE);
		}
		ROS_INFO("Successfully parsed urdf file");

		/// Get max velocities out of urdf model
		std::vector<double> MaxVelocities(dof_);
		for (int i = 0; i < dof_; i++)
		{
			//MaxVelocities[i] = model.getJoint(config.joint_names[i].c_str())->limits->velocity;
			MaxVelocities[i] = model.getJoint(joint_names_[i].c_str())->limits->velocity; // HACK: does not work yet because BRIDE doesn't support list parameters
			std::cout << "MaxVelocities[" << joint_names_[i].c_str() <<"]: " << MaxVelocities[i] << std::endl;
		}

		/// Get lower limits out of urdf model
		std::vector<double> LowerLimits(dof_);
		for (int i = 0; i < dof_; i++)
		{
			//LowerLimits[i] = model.getJoint(config.joint_names[i].c_str())->limits->lower;
			LowerLimits[i] = model.getJoint(joint_names_[i].c_str())->limits->lower; // HACK: does not work yet because BRIDE doesn't support list parameters
			std::cout << "LowerLimits[" << joint_names_[i].c_str() <<"]: " << LowerLimits[i] << std::endl;
		}

		// Get upper limits out of urdf model
		std::vector<double> UpperLimits(dof_);
		for (int i = 0; i < dof_; i++)
		{
			//UpperLimits[i] = model.getJoint(config.joint_names[i][i].c_str())->limits->upper;
			UpperLimits[i] = model.getJoint(joint_names_[i].c_str())->limits->upper; // HACK: does not work yet because BRIDE doesn't support list parameters
		}

		/// Get offsets out of urdf model
		std::vector<double> Offsets(dof_);
		for (int i = 0; i < dof_; i++)
		{
			//Offsets[i] = model.getJoint(config.joint_names[i][i].c_str())->calibration->rising.get()[0];
			Offsets[i] = model.getJoint(joint_names_[i].c_str())->calibration->rising.get()[0]; // HACK: does not work yet because BRIDE doesn't support list parameters
		}

    	/* protected region user configure end */
    }
    void update(canopen_ros_data &data, canopen_ros_config config)
    {
        /* protected region user update on begin */
    	ROS_WARN("update start");
    	if (is_initialized_)
    	{
    		//TODO:
    		//send new vel to canopen
    		//std::cout << data.in_command_vel << std::endl;
    		//move(data.in_command_vel)

    		//get current joint states
    		//joint_pos = ...
    		//joint_vel = ...

    		//set current joint_states to out_joint_state and out_state
    		//data.out_joint_state =
    		//data.out_state =

    		//get diagnostics info from canopen
    		diagnostic_msgs::DiagnosticStatus diagnostic_status;
    		//diagnostic_status = ...

    		//set diagostics to out_diagnostics
    		data.out_diagnostics.status.push_back(diagnostic_status);
    	}
		/* protected region user update end */
    }

	bool callback_init(cob_srvs::Trigger::Request  &req, cob_srvs::Trigger::Response &res , canopen_ros_config config)
	{
		/* protected region user implementation of service callback for init on begin */
		ROS_INFO("Initializing canopen...");
		if (!is_initialized_)
		{
			is_initialized_ = canopen::openConnection(config.can_device); // TODO: fill in canopen command
			if (is_initialized_)
			{
			   res.success.data = true;
			   res.error_message.data = "initializing canopen successful";
			  ROS_INFO("... initializing canopen successful");
			}
			else
			{
			  res.success.data = false;
			  res.error_message.data = "dummy error message"; // TODO get error message from canopen
			  ROS_ERROR("...initializing canopen not successful. error: %s", res.error_message.data.c_str());
			}
		}
		else
		{
			res.success.data = true;
			res.error_message.data = "canopen already initialized, please user recover";
			ROS_WARN("...initializing canopen not successful. error: %s",res.error_message.data.c_str());
		}

		/* protected region user implementation of service callback for init end */
		return true;
	}
	bool callback_recover(cob_srvs::Trigger::Request  &req, cob_srvs::Trigger::Response &res , canopen_ros_config config)
	{
		/* protected region user implementation of service callback for recover on begin */
		ROS_INFO("Recovering canopen...");
		if (is_initialized_)
		{
			bool is_recovered = false; // TODO: fill in canopen command
			if (is_recovered)
			{
				res.success.data = true;
				res.error_message.data = "recovering canopen successful";
				ROS_INFO("...recovering canopen successful.");
			}
			else
			{
				res.success.data = false;
				res.error_message.data = "dummy error message"; // TODO get error message from canopen;
				ROS_ERROR("...recovering canopen not successful. error: %s", res.error_message.data.c_str());
			}
		}
		else
		{
		  res.success.data = false;
		  res.error_message.data = "canopen not initialized, please use init first";
		  ROS_WARN("...recovering canopen not successful. error: %s",res.error_message.data.c_str());
		}
		/* protected region user implementation of service callback for recover end */
		return true;
	}
    


    
    /* protected region user additional functions on begin */
	/* protected region user additional functions end */
    
};
